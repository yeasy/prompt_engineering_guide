## README.md
- 大模型提示词工程指南
  - 关于本书
  - 目标读者
  - 阅读收获
    - 理论基础
    - 实践技能
    - 高级应用
    - 行业洞察
  - 本书特色
  - 如何使用本书
  - 📖 阅读方式
  - 版本信息

## 01_introduction/README.md
- 第一章：提示词工程概述
  - 本章内容

## 01_introduction/1.1_what_is_prompt_engineering.md
  - 1.1 什么是提示词工程
    - 1.1.1 提示词的基本概念
    - 1.1.2 提示词工程的定义
    - 1.1.3 提示词工程的核心任务
    - 1.1.4 提示词与传统编程的比较
    - 1.1.5 提示词工程的层次模型
    - 想一想

## 01_introduction/1.2_history.md
  - 1.2 提示词工程的发展历程
    - 1.2.1 早期探索：规则与模板时代（2010年代前）
    - 1.2.2 预训练语言模型的兴起（2018-2020年）
    - 1.2.3 提示词工程的形成与爆发（2021-2022年）
    - 1.2.4 成熟与专业化（2023-2026年）
    - 1.2.5 当下与未来：从提示词工程到上下文工程
    - 1.2.6 发展历程时间线
    - 延伸思考

## 01_introduction/1.3_importance_and_scenarios.md
  - 1.3 提示词工程的重要性与应用场景
    - 1.3.1 模型能力与实际效果的鸿沟
    - 1.3.2 核心价值体系
    - 1.3.3 典型应用场景
    - 1.3.4 应用场景选择矩阵
    - 1.3.5 战略意义
    - 思考

## 01_introduction/summary.md
- 第一章：提示词工程概述
  - 本章小结
    - 关键概念
    - 核心要点
    - 核心技能图谱
    - 延伸阅读
    - 下一章预告

## 02_llm_basics/README.md
- 第二章：大语言模型基础
  - 本章内容

## 02_llm_basics/2.1_how_llm_works.md
  - 2.1 大语言模型的工作原理
    - 2.1.1 从语言建模说起
    - 2.1.2 Transformer 架构
    - 2.1.3 Token：模型理解的基本单位
    - 2.1.4 训练过程：预训练与微调
    - 2.1.5 推理过程：从提示词到输出
    - 2.1.6 涌现能力
    - 2.1.7 对提示词设计的启示
    - 想一想

## 02_llm_basics/2.2_major_models.md
  - 2.2 主流大语言模型概览
    - 2.2.1 OpenAI GPT 系列
    - 2.2.2 Anthropic Claude 系列
    - 2.2.3 Google Gemini 系列
    - 2.2.4 Meta Llama 系列
    - 2.2.5 国产大语言模型
    - 2.2.6 模型选择指南
    - 2.2.7 跨模型的提示词策略
    - 讨论

## 02_llm_basics/2.3_parameters.md
  - 2.3 模型参数与输出控制
    - 2.3.1 Temperature（温度）
    - 2.3.2 Top-p（核采样）
    - 2.3.3 Top-k
    - 2.3.4 Max Tokens（最大 Token 数）
    - 2.3.5 停止序列
    - 2.3.6 Presence Penalty（存在惩罚）
    - 2.3.7 Frequency Penalty（频率惩罚）
    - 2.3.8 参数组合策略
    - 2.3.9 参数调优流程
    - 2.3.10 与提示词设计的协同
    - 动手试试

## 02_llm_basics/2.4_context_window.md
  - 2.4 上下文窗口与信息处理
    - 2.4.1 什么是上下文窗口
    - 2.4.2 主流模型的上下文限制
    - 2.4.3 上下文窗口的组成
    - 2.4.4 上下文窗口的有效利用
    - 2.4.5 对话历史管理
    - 2.4.6 长上下文的挑战与应对
    - 2.4.7 上下文窗口与提示词设计
  - 任务背景
  - 具体任务
  - 输出要求
  - 输入内容
    - 延伸思考

## 02_llm_basics/summary.md
- 第二章：大语言模型基础
  - 本章小结
    - 关键概念
    - 核心要点
    - 与提示词工程的关联
    - 实践建议
    - 延伸阅读
    - 下一章预告

## 03_prompt_structure/README.md
- 第三章：提示词的基本结构
  - 本章内容

## 03_prompt_structure/3.1_core_elements.md
  - 3.1 提示词的核心组成要素
    - 3.1.1 要素一：角色/身份
    - 3.1.2 要素二：任务指令
    - 3.1.3 要素三：上下文
    - 3.1.4 要素四：输入数据
    - 3.1.5 要素五：输出格式
    - 3.1.6 要素六：示例
    - 3.1.7 要素组合示例
- 角色
- 任务
- 上下文
- 输出格式
- 示例
- 待分析评论
    - 动手试试

## 03_prompt_structure/3.2_instruction_principles.md
  - 3.2 指令设计的基本原则
    - 3.2.1 原则一：清晰明确
    - 3.2.2 原则二：具体细致
    - 3.2.3 原则三：使用行动导向的语言
    - 3.2.4 原则四：逻辑顺序
    - 3.2.5 原则五：正向表达
    - 3.2.6 原则六：考虑边界情况
    - 3.2.7 原则七：迭代优化
    - 3.2.8 实战示例：指令优化过程
    - 延伸思考

## 03_prompt_structure/3.3_context.md
  - 3.3 上下文与背景信息的提供
    - 3.3.1 上下文的重要性
    - 3.3.2 上下文的类型
    - 3.3.3 上下文组织的最佳实践
  - 背景信息
  - 任务要求
  - 待处理内容
    - 3.3.4 上下文来源策略
    - 3.3.5 上下文的动态管理
    - 3.3.6 常见问题与解决方案
    - 思考

## 03_prompt_structure/3.4_output_format.md
  - 3.4 输出格式的定义与约束
    - 3.4.1 为什么输出格式很重要
    - 3.4.2 常见输出格式类型
- 主标题
  - 1. 第一部分
  - 2. 第二部分
  - 3. 总结
    - 3.4.3 格式约束的设计方法
    - 3.4.4 高级格式控制技巧
    - 3.4.5 特殊格式需求
- 使用示例
    - 3.4.6 格式一致性保障
    - 3.4.7 常见问题处理
    - 想一想

## 03_prompt_structure/3.5_structured_output.md
  - 3.5 结构化输出的定义与约束
    - 3.5.1 主流结构化格式对比
    - 3.5.2 JSON 模式的提示词设计
    - 3.5.3 各平台的结构化输出特性
    - 3.5.4 解析错误处理策略
    - 思考

## 03_prompt_structure/summary.md
- 第三章：提示词的基本结构
  - 本章小结
    - 关键概念
    - 核心要点
    - 提示词结构模板
- 角色定义
- 任务背景
- 具体任务
- 约束条件
- 输出格式
- 示例（可选）
- 待处理内容
    - 实践检查清单
    - 延伸阅读
    - 下一章预告

## 04_best_practices/README.md
- 第四章：提示词设计最佳实践
  - 本章内容

## 04_best_practices/4.1_clarity_specificity.md
  - 4.1 清晰性与具体性原则
    - 4.1.1 清晰性原则
    - 4.1.2 具体性原则
    - 4.1.3 清晰性与简洁性的平衡
    - 4.1.4 实用技巧
    - 4.1.5 检查清单
    - 动手试试

## 04_best_practices/4.2_delimiters.md
  - 4.2 分隔符与结构化表达
    - 4.2.1 分隔符的作用
    - 4.2.2 常用分隔符类型
- 任务说明
  - 背景信息
  - 待分析数据
  - 输出要求
    - 4.2.3 选择分隔符的原则
    - 4.2.4 结构化表达技术
  - 1. 角色设定
  - 2. 任务描述
  - 3. 评估维度
  - 4. 输出格式
  - 5. 待评估内容
    - 4.2.5 实战案例：提示词结构化改造
- 任务：电商产品评论分析
  - 产品信息
  - 分析维度
  - 输出要求
  - 待分析评论
    - 4.2.6 安全性考虑
    - 4.2.7 常见问题处理
    - 想一想

## 04_best_practices/4.3_role_setting.md
  - 4.3 角色设定与人格赋予
    - 4.3.1 角色设定的价值
    - 4.3.2 角色设定的构成要素
    - 4.3.3 角色设定的层次
- 角色定义：企业培训顾问
  - 身份背景
  - 核心能力
  - 沟通风格
  - 行为准则
  - 服务对象
    - 4.3.4 角色设定的技巧
    - 4.3.5 角色设定的注意事项
    - 4.3.6 角色设定模板
  - 角色：[角色名称]
    - 4.3.7 身份定义
    - 4.3.8 专业背景
    - 4.3.9 沟通风格
    - 4.3.10 行为准则
    - 4.3.11 目标受众
    - 讨论

## 04_best_practices/4.4_iteration.md
  - 4.4 迭代优化与测试方法
    - 4.4.1 迭代优化的基本流程
    - 4.4.2 第一步：建立基准
  - 产品评论情感分析测试集
    - 4.4.3 第二步：系统化测试
  - 测试日志
    - 4.4.4 第三步：问题诊断
    - 4.4.5 第四步：优化策略
    - 4.4.6 第五步：验证与固化
  - 提示词文档
    - 4.4.7 自动化测试建议
- 提示词自动化测试伪代码
    - 实践建议

## 04_best_practices/4.5_system_prompt_design.md
  - 4.5 System Prompt 系统设计
    - 4.5.1 System Prompt 的核心定位
    - 4.5.2 结构化 System Prompt 设计范式
- 身份与使命
- 行为准则
- 审查规则清单
- 输出格式
  - 代码总评
  - 改进建议
  - 重构示例
    - 4.5.3 长 System Prompt 的组织与管理
    - 4.5.4 User Prompt 与 System Prompt 的协同
- 良性协同的代码示例
    - 思考

## 04_best_practices/summary.md
- 第四章：提示词设计最佳实践
  - 本章小结
    - 关键概念
    - 核心要点
    - 最佳实践速查表
    - 常见问题与解决方案
    - 延伸阅读
    - 下一章预告

## 05_few_shot/README.md
- 第五章：少样本学习与示例驱动
  - 本章内容

## 05_few_shot/5.1_zero_shot_few_shot.md
  - 5.1 零样本与少样本提示
    - 5.1.1 零样本提示
    - 5.1.2 单样本提示
    - 5.1.3 少样本提示
    - 5.1.4 三种方式的对比
    - 5.1.5 选择合适的方式
    - 5.1.6 由零到多的渐进策略
    - 5.1.7 上下文学习的本质
    - 思考

## 05_few_shot/5.2_example_design.md
  - 5.2 示例的选择与设计策略
    - 5.2.1 优质示例的特征
    - 5.2.2 示例数量的选择
    - 5.2.3 示例的组织结构
    - 5.2.4 示例选择策略
    - 5.2.5 示例设计的注意事项
    - 5.2.6 动态示例选择
    - 思考

## 05_few_shot/5.3_applications.md
  - 5.3 少样本学习的应用场景
    - 5.3.1 场景一：文本分类
    - 5.3.2 场景二：信息提取
    - 5.3.3 场景三：格式转换
    - 5.3.4 场景四：风格转换
    - 5.3.5 场景五：翻译与本地化
    - 5.3.6 场景六：创意生成
    - 5.3.7 实践技巧总结
    - 动手试试

## 05_few_shot/5.4_troubleshooting.md
  - 5.4 常见问题与解决方案
    - 5.4.1 问题一：示例数量不足或过多
    - 5.4.2 问题二：示例与实际输入差异大
    - 5.4.3 问题三：输出格式不一致
    - 5.4.4 问题四：模型复制示例而非学习模式
    - 5.4.5 问题五：边界情况处理不当
    - 5.4.6 问题六：示例顺序影响结果
    - 5.4.7 问题七：Token 限制
    - 5.4.8 问题诊断流程
    - 想一想

## 05_few_shot/5.5_practice.md
- 5.5 本章实战练习
  - 练习一：情感分析对比实验（基础通用）
  - 练习二：脏数据清洗与提取（进阶技巧）
  - 练习三：构建动态意图识别器（实战场景）
- 调用 API 进行测试...
  - 参考实现代码
    - 1. 零样本与少样本对比 (Zero-Shot vs Few-Shot)
- 模拟 LLM 调用函数 (在实际使用中请替换为真实的 OpenAI/Anthropic API 调用)
    - 2. 动态示例选择器 (Dynamic Selector)
- 演示

## 05_few_shot/summary.md
- 第五章：少样本学习与示例驱动
  - 本章小结
    - 关键概念
    - 核心要点
    - 常见问题速查
    - 最佳实践检查清单
    - 延伸阅读
    - 下一章预告

## 06_chain_of_thought/README.md
- 第六章：思维链与推理增强
  - 本章内容

## 06_chain_of_thought/6.1_cot_principles.md
  - 6.1 思维链提示的原理与价值
    - 6.1.1 什么是思维链提示
    - 6.1.2 为什么思维链有效
    - 6.1.3 思维链的适用场景
    - 6.1.4 与模型规模的关系
    - 6.1.5 思维链提示的基本形式
    - 6.1.6 思维链的输出示例
    - 6.1.7 思维链的价值总结
    - 思考

## 06_chain_of_thought/6.2_zero_few_shot_cot.md
  - 6.2 零样本与少样本思维链
    - 6.2.1 零样本思维链
    - 6.2.2 少样本思维链
    - 6.2.3 零样本与少样本对比
    - 6.2.4 选择策略
    - 6.2.5 少样本CoT的示例设计
    - 6.2.6 增强零样本CoT的技巧
    - 6.2.7 常见问题与解决方案
    - 延伸思考

## 06_chain_of_thought/6.3_self_consistency.md
  - 6.3 自一致性与多路径推理
    - 6.3.1 自一致性的核心思想
    - 6.3.2 实现方法
    - 6.3.3 自一致性的优势
    - 6.3.4 实现示例
- 自一致性伪代码
    - 6.3.5 采样策略
    - 6.3.6 变体技术
    - 6.3.7 适用场景
    - 6.3.8 实践建议
    - 讨论

## 06_chain_of_thought/6.4_tree_of_thought.md
  - 6.4 思维树与高级推理策略
    - 6.4.1 思维树概述
    - 6.4.2 思维树的核心组件
    - 6.4.3 思维树的应用示例
    - 6.4.4 提示词实现思维树
    - 6.4.5 其他高级推理策略
    - 6.4.6 选择合适的推理策略
    - 6.4.7 实践建议
    - 思考

## 06_chain_of_thought/6.5_reasoning_models.md
  - 6.5 Reasoning 模型专题：内置推理范式
    - 6.5.1 Reasoning 模型的工作原理
    - 6.5.2 传统 CoT 模型 vs Reasoning 模型的提示策略
    - 6.5.3 针对 Reasoning 模型的最佳实践
    - 6.5.4 混合架构的未来：Router 模式
    - 思考

## 06_chain_of_thought/6.6_practice.md
- 6.6 本章实战练习
  - 练习一：数学应用题（基础通用）
  - 练习二：逻辑谜题与反事实推理（进阶技巧）
  - 练习三：财务报表稽核模拟（实战场景）
  - 参考实现代码
    - 1. 简单的思维链示例 (Simple CoT)
    - 2. 自我一致性演示 (Self-Consistency)

## 06_chain_of_thought/summary.md
- 第六章：思维链与推理增强
  - 本章小结
    - 关键概念
    - 核心要点
    - 推理策略选择指南
    - 实践技巧
    - 延伸阅读
    - 下一章预告

## 07_prompt_chaining/README.md
- 第七章：提示词链与任务分解
  - 本章内容

## 07_prompt_chaining/7.1_task_decomposition.md
  - 7.1 复杂任务的分解艺术
    - 7.1.1 为什么需要任务分解
    - 7.1.2 识别可分解的任务
    - 7.1.3 分解策略
    - 7.1.4 分解原则
    - 7.1.5 分解流程
    - 动手试试

## 07_prompt_chaining/7.2_chaining_patterns.md
  - 7.2 提示词链的设计模式
    - 7.2.1 模式一：顺序链
- 文档摘要生成管道
    - 7.2.2 模式二：分支链
- 智能客服分支处理
    - 7.2.3 模式三：并行链
- 产品评论多维度分析
    - 7.2.4 模式四：循环链
- 文本改写迭代优化
    - 7.2.5 模式五：验证链
- JSON生成与验证
    - 7.2.6 模式六：层级链
- 完整报告生成
    - 7.2.7 模式选择指南
    - 7.2.8 模式组合
    - 延伸思考

## 07_prompt_chaining/7.3_context_passing.md
  - 7.3 上下文传递与状态管理
    - 7.3.1 上下文传递的挑战
    - 7.3.2 传递策略
    - 7.3.3 状态管理模式
- 步骤1执行后
- 步骤2可以访问
- 步骤1完成后
- 步骤2需要时
    - 7.3.4 实现最佳实践
- 步骤接口定义
  - 上一步结果
  - 当前任务
  - 输出要求
    - 7.3.5 上下文压缩技术
    - 想一想

## 07_prompt_chaining/7.4_case_study.md
  - 7.4 实战案例：构建多步骤工作流
    - 7.4.1 案例背景
    - 7.4.2 任务分解
    - 7.4.3 各步骤提示词设计
- 步骤1：信息整理
  - 输入信息
  - 任务
  - 输出格式
- 步骤2：功能对比分析
  - 产品信息
  - 任务
  - 输出格式
- 步骤3：定价分析
  - 产品信息
  - 任务
  - 输出格式
- 步骤4：SWOT分析
  - 功能对比结果
  - 定价分析结果
  - 任务
  - 输出格式
- 步骤5：综合报告生成
  - 分析数据
    - 7.4.4 产品信息
    - 7.4.5 功能对比
    - 7.4.6 定价分析
    - 7.4.7 SWOT分析
  - 任务
  - 报告结构
  - 格式要求
- 步骤6：报告质量检查
  - 报告内容
  - 检查项目
  - 输出格式
    - 7.4.8 工作流实现框架
    - 7.4.9 关键实现细节
    - 讨论

## 07_prompt_chaining/7.5_multi_turn_dialogue.md
  - 7.5 多轮对话管理
    - 7.5.1 对话历史的剪裁与摘要策略
    - 7.5.2 多轮上下文中的指令漂移 (Instruction Drift)
    - 7.5.3 状态机模式：管理复杂的引导流程
    - 思考

## 07_prompt_chaining/7.6_practice.md
- 7.6 本章实战练习
  - 练习一：构建简单的顺序链（基础设计）
  - 练习二：设计带验证环节的并行链（进阶架构）
  - 练习三：复杂长表单的多轮实体抽取架构（实战挑战）

## 07_prompt_chaining/summary.md
- 第七章：提示词链与任务分解
  - 本章小结
    - 关键概念
    - 核心要点
    - 实战案例要点
    - 实践检查清单
    - 延伸阅读
    - 下一章预告

## 08_react_tools/README.md
- 第八章：ReAct与工具使用
  - 本章内容

## 08_react_tools/8.1_react_framework.md
  - 8.1 ReAct 框架：推理与行动的结合
    - 8.1.1 核心原理：超越思维链
    - 8.1.2 实战示例：ReAct 解决复杂问题
    - 8.1.3 ReAct 的代码实现逻辑
    - 8.1.4 ReAct 的优势与局限
    - 想一想

## 08_react_tools/8.2_function_calling.md
  - 8.2 函数调用与工具集成
    - 8.2.1 为什么需要原生函数调用？
    - 8.2.2 定义工具：JSON Schema 的力量
    - 8.2.3 并行函数调用 (Parallel Function Calling)
    - 8.2.4 错误处理与鲁棒性设计
    - 8.2.5 安全警示：间接提示注入
    - 动手试试

## 08_react_tools/8.3_external_knowledge.md
  - 8.3 外部知识源的接入
    - 1. 互联网搜索：获取实时信息
- 系统提示词
- 伪代码示例
    - 2. 数据库查询：Text-to-SQL
    - 3. 知识库检索 (RAG 集成)
    - 4. 知识整合与冲突处理
    - 讨论

## 08_react_tools/8.4_agent_prompts.md
  - 8.4 Agent 系统的提示词设计
    - 8.4.1 核心设计原则
    - 8.4.2 模板一：通用 ReAct Agent
- Role
- Tools
- Protocol
- Constraints
- Example
    - 8.4.3 模板二：数据分析 SQL Agent
- Role
- Database Schema
- Instructions
- Security Rules
- Output Format
    - 8.4.4 模板三：规划型 Agent (Planner)
- Role
- Workflow
- Output Format
    - 8.4.5 模板四：分层行动空间 Agent (OS-World)
- Agent 通过 shell 发现可用工具
- Agent 调用工具
- Agent 生成的脚本：分析一整年股票数据
- Role
- Environment Layers
- Decision Protocol
- Output Format
    - 8.4.6 进阶技巧：自反思 (Reflexion)
    - 延伸思考

## 08_react_tools/8.5_practice.md
- 8.5 本章实战练习
  - 练习一：理解 ReAct 的 Thought-Action 循环
  - 练习二：设计函数调用 (Function / Tool Schema)
  - 练习三：防范"工具级联故障" (Tool Cascading Failure)

## 08_react_tools/summary.md
- 第八章：ReAct与工具使用
  - 本章小结
    - 关键概念
    - 核心要点
    - 实践要点

## 09_rag/README.md
- 第九章：检索增强生成
  - 本章内容

## 09_rag/9.1_rag_principles.md
  - 9.1 RAG 系统的核心原理
    - 9.1.1 为什么需要 RAG？
    - 9.1.2 RAG 的标准架构
    - 9.1.3 RAG 架构的演进
    - 9.1.4 核心挑战与评估
    - 想一想

## 09_rag/9.2_retrieval_strategies.md
  - 9.2 高级检索策略与上下文组装
    - 1. 混合检索 (Hybrid Search)
    - 2. 重排序 (Reranking / Two-Stage Retrieval)
    - 3. 查询转换 (Query Transformation)
    - 4. 分块与索引优化 (Chunking & Indexing)
    - 5. 上下文组装 (Context Construction)
    - 9.2.1 关键参数推荐
    - 延伸思考

## 09_rag/9.3_rag_prompt_optimization.md
  - 9.3 RAG 系统的提示词优化
    - 1. 上下文注入格式 (Context Injection)
    - 2. 引用与溯源 (Citations)
    - 3. 拒绝幻觉 (Negative Constraints)
    - 4. 答案优化与合成
    - 9.3.1 完整模板示例
- Role
- Task
- Context
- Rules
- User Question
- Answer
    - 动手试试

## 09_rag/9.4_advanced_rag.md
  - 9.4 高级 RAG 架构与前沿趋势
    - 1. 模块化与自适应 RAG
    - 2. GraphRAG：融合知识图谱
    - 3. 长上下文 RAG (Long-Context RAG)
    - 4. RAG 评估体系 (RAG Evaluation)
    - 5. RAG 模型微调 (RAG Fine-tuning)
    - 讨论

## 09_rag/9.5_practice.md
- 9.5 本章实战练习
  - 练习一：设计带有引用的 RAG 回答框架
  - 练习二：处理冲突信息 (Information Conflict)
  - 练习三：拒绝回答越界问题 (Out-of-Domain Rejection)

## 09_rag/summary.md
- 第九章：检索增强生成
  - 本章小结
    - 核心要点
    - 关键实践

## 10_multimodal/README.md
- 第十章：多模态提示工程
  - 本章内容

## 10_multimodal/10.1_multimodal_overview.md
  - 10.1 多模态模型概述
    - 10.1.1 多模态模型的技术演进
    - 10.1.2 主流多模态模型对比
    - 10.1.3 多模态能力的四大支柱
    - 10.1.4 多模态提示词的核心原则
    - 10.1.5 多模态应用场景
    - 想一想

## 10_multimodal/10.2_image_prompting.md
  - 10.2 图像理解与视觉提示
    - 10.2.1 图像理解的能力边界
    - 10.2.2 基本图像提示模式
    - 10.2.3 高级图像提示技巧
    - 10.2.4 图像提示的常见陷阱
    - 10.2.5 实践案例：电商场景
  - 分析维度
    - 1. 首图吸引力 (针对第1张)
    - 2. 卖点传达 (针对第2-4张)
    - 3. 整体一致性 (针对全部5张)
  - 输出格式
    - 动手试试

## 10_multimodal/10.3_audio_video.md
  - 10.3 音频与视频处理
    - 10.3.1 音频处理能力现状
    - 10.3.2 音频提示设计
    - 10.3.3 视频处理能力现状
    - 10.3.4 视频提示设计
  - 内容摘要
  - 时间轴标注
  - 演示亮点
  - 待改进项
    - 10.3.5 长视频处理策略
- 伪代码示例
    - 10.3.6 音视频提示的关键原则
    - 延伸思考

## 10_multimodal/10.4_cross_modal_reasoning.md
  - 10.4 跨模态推理与融合
    - 10.4.1 跨模态推理的价值
    - 10.4.2 跨模态提示设计模式
  - 任务
  - 分析维度
  - 输出格式
  - 任务
  - 分析框架
  - 当前状态分析
  - 因果推理
  - 建议决策
  - 输出要求
    - 10.4.3 复杂跨模态任务示例
    - 10.4.4 跨模态推理的局限与注意事项
    - 思考

## 10_multimodal/10.5_practice.md
- 10.5 本章实战练习
  - 练习一：视觉界面逆向工程 (UI to Code)
  - 练习二：图表数据深度提取 (Chart Understanding)
  - 练习三：视频关键帧联合分析 (Video Summarization)

## 10_multimodal/summary.md
- 第十章：多模态提示工程
  - 本章小结
    - 核心要点
    - 关键原则

## 11_safety_reliability/README.md
- 第十一章：安全性与可靠性
  - 本章内容

## 11_safety_reliability/11.1_prompt_injection.md
  - 11.1 提示词注入与防护策略
    - 11.1.1 什么是提示词注入
    - 11.1.2 注入攻击类型
    - 11.1.3 防护策略体系
  - 安全规则（最高优先级）
  - 核心任务
  - 可用功能
  - 回应规范
    - 11.1.4 高级防护技术
- 在系统提示词中嵌入特殊标记
    - 11.1.5 实战检测清单
    - 思考

## 11_safety_reliability/11.2_hallucination.md
  - 11.2 幻觉问题与事实性保障
    - 11.2.1 理解幻觉的本质
    - 11.2.2 幻觉的类型
    - 11.2.3 幻觉的严重程度评估
    - 11.2.4 检测幻觉的方法
    - 11.2.5 减少幻觉的策略
    - 11.2.6 不同场景的幻觉风险管理
    - 11.2.7 实战案例：构建抗幻觉的问答系统
    - 思考

## 11_safety_reliability/11.3_bias_fairness.md
  - 11.3 偏见识别与公平性考量
    - 11.3.1 偏见的来源与类型
    - 11.3.2 偏见识别方法
    - 11.3.3 偏见缓解策略
- 偏见检测示例（伪代码）
    - 11.3.4 行业合规要求
    - 11.3.5 公平性评估指标
    - 讨论

## 11_safety_reliability/11.4_enterprise_security.md
  - 11.4 企业级安全架构设计
    - 11.4.1 企业 AI 安全的核心挑战
    - 11.4.2 分层安全架构
    - 11.4.3 应用层安全
- 企业级认证示例
- 限流策略配置
    - 11.4.4 模型层安全
    - 11.4.5 数据层安全
- 向量数据库访问控制
    - 11.4.6 运维层安全
- 监控告警规则
    - 11.4.7 合规框架
    - 实践建议

## 11_safety_reliability/11.5_practice.md
- 11.5 本章实战练习
  - 练习一：简单的注入攻击模拟（基础通用）
  - 练习二：构建"三明治"防御（进阶技巧）
  - 练习三：内容安全过滤器设计（实战场景）
- 生成层
- 过滤层
  - 参考实现代码
    - 1. 提示词注入测试 (Prompt Injection Test)
    - 2. 幻觉检测示例 (Hallucination Check)

## 11_safety_reliability/summary.md
- 第十一章：安全性与可靠性
  - 本章小结
    - 核心要点
    - 关键措施

## 12_automated_pe/README.md
- 第十二章：自动化提示词工程
  - 本章内容

## 12_automated_pe/12.1_auto_generation.md
  - 12.1 自动化提示词生成技术
    - 12.1.1 自动化提示词的核心价值
    - 12.1.2 APE：自动提示词工程
    - 12.1.3 元提示：用提示词生成提示词
  - 任务信息
  - 约束条件
  - 示例数据
  - 设计要求
  - 输出格式
    - 12.1.4 基于反馈的迭代优化
    - 12.1.5 自动化提示词搜索算法
    - 12.1.6 实践建议
    - 想一想

## 12_automated_pe/12.2_optimization_tools.md
  - 12.2 提示词优化与调优工具
    - 12.2.1 工具生态概览
    - 12.2.2 提示词开发框架
- 基础模板
- 生成提示词
- Chat 模板
- 少样本模板
- 查询改写模板
- RAG 回答模板
    - 12.2.3 版本控制与监控工具
- 初始化（包装 OpenAI 客户端）
- 调用时自动记录
- 功能：
- - 所有调用自动记录和可视化
- - 提示词版本管理
- - A/B 测试支持
- - 成本追踪
- 初始化
- 记录提示词实验
- 记录指标
    - 12.2.4 交互式调试工具
    - 12.2.5 自动化测试工具
- promptfoo.yaml - 测试配置
- 定义签名（任务规范）
- 使用模块
- 自动优化
    - 12.2.6 优化工作流最佳实践
    - 动手试试

## 12_automated_pe/12.3_evaluation.md
  - 12.3 评估体系与质量度量
    - 12.3.1 为什么需要系统化评估
    - 12.3.2 评估维度框架
    - 12.3.3 评估方法详解
    - 12.3.4 构建评估测试集
    - 12.3.5 自动化评估流水线
    - 12.3.6 监控与持续评估
- 生产环境输出采样评估
    - 12.3.7 评估最佳实践
    - 延伸思考

## 12_automated_pe/12.4_promptops.md
  - 12.4 PromptOps：提示词运维实践
    - 12.4.1 PromptOps 的核心理念
    - 12.4.2 版本控制最佳实践
- customer_service_v2.1.0.yaml
    - 12.4.3 环境管理
- environments.yaml
    - 12.4.4 监控与告警
- monitoring_config.yaml
    - 12.4.5 灰度发布策略
    - 12.4.6 回滚机制
    - 实践建议

## 12_automated_pe/12.5_practice.md
- 12.5 本章实战练习
  - 练习一：基于 DSPy 的自动编译体验
  - 练习二：编写鲁棒的 LLM-as-a-Judge 评估器
  - 练习三：搭建最简版 PromptOps 流水线

## 12_automated_pe/summary.md
- 第十二章：自动化提示词工程
  - 本章小结
    - 核心要点
    - 关键实践

## 13_platform_specific/README.md
- 第十三章：平台特定策略
  - 本章内容

## 13_platform_specific/13.1_openai_gpt.md
  - 13.1 OpenAI GPT 系列最佳实践
    - 13.1.1 GPT 模型系列概览
    - 13.1.2 系统提示词设计
    - 13.1.3 函数调用与结构化输出
- 返回结果自动解析为 Python 对象
    - 13.1.4 o1/o3 推理模型策略
    - 13.1.5 高级技巧
    - 13.1.6 背景信息 ###
    - 13.1.7 任务要求 ###
    - 13.1.8 输出格式 ###
- 保持关键信息在上下文开头和结尾
    - 13.1.9 常见问题与解决方案
    - 动手试试

## 13_platform_specific/13.2_anthropic_claude.md
  - 13.2 Anthropic Claude 提示技巧
    - 13.2.1 Claude 模型系列
    - 13.2.2 XML 标签：Claude 的提示词利器
    - 13.2.3 预填充技术
- Claude 将从预填充位置继续：{"sentiment": "mixed", "details": ...}
- Claude 将输出完整的 JSON，并以 ``` 结尾
    - 13.2.4 扩展思考
- 访问思考过程
    - 13.2.5 长上下文处理策略
    - 13.2.6 安全与对齐特性
    - 13.2.7 实战示例：复杂文档分析
  - 财务指标摘要
  - 风险信号
  - 增长潜力评估
  - 投资建议
    - 想一想

## 13_platform_specific/13.3_google_gemini.md
  - 13.3 Google Gemini 提示策略
    - 13.3.1 Gemini 模型系列
    - 13.3.2 原生多模态能力
- 混合多种模态
    - 13.3.3 多模态提示词设计
    - 13.3.4 超长上下文处理策略
    - 13.3.5 Google 生态集成
- 使用 Grounding 功能接入最新信息
    - 13.3.6 结构化输出指定
    - 13.3.7 提示词模板示例
    - 13.3.8 常见问题与解决方案
    - 延伸思考

## 13_platform_specific/13.4_open_source.md
  - 13.4 开源模型的提示词适配
    - 13.4.1 开源模型生态概览
    - 13.4.2 提示词模板格式
    - 13.4.3 Instruction:
    - 13.4.4 Response:
    - 13.4.5 模型特定的提示词策略
- 使用 Ollama 调用 Llama 3
- Qwen 中文提示词示例
    - 13.4.6 本地部署与推理优化
- 安装模型
- 运行对话
- 作为 API 服务
- 指向本地服务
    - 13.4.7 开源模型的能力边界
    - 13.4.8 提示词适配最佳实践
    - 讨论

## 13_platform_specific/13.5_cross_platform_strategy.md
  - 13.5 跨模型提示词策略 (Cross-Platform Strategy)
    - 13.5.1 提示词的"移植性"矩阵
    - 13.5.2 核心策略：适配器模式 (Adapter Pattern)
- 使用示例
- 调用 GPT
- client.chat.completions.create(model="gpt-4o", messages=gpt_messages)
- 调用 Claude
- client.messages.create(model="claude-3-5-sonnet", messages=claude_messages)
    - 13.5.3 元提示词 (Meta-Prompting) 自动转换
- Role
- Task
- Target Model Specifications
- Generic Prompt
- Output
    - 13.5.4 生产环境建议
    - 思考

## 13_platform_specific/13.6_practice.md
- 13.6 本章实战练习
  - 练习一：系统级指令的跨平台移植
  - 练习二：用 Structured Outputs 规范 OpenAI API 回调
  - 练习三：适配本地开源小模型的 Prompt 降级策略

## 13_platform_specific/summary.md
- 第十三章：平台特定策略
  - 本章小结
    - 平台特性总结
    - 关键建议
    - 实战练习核心

## 14_future/README.md
- 第十四章：未来趋势与展望
  - 本章内容

## 14_future/14.1_context_engineering.md
  - 14.1 从提示词工程到上下文工程
    - 14.1.1 什么是上下文工程
    - 14.1.2 为什么上下文工程至关重要
    - 14.1.3 核心概念对比
    - 14.1.4 上下文失效模式
    - 14.1.5 上下文工程的核心组件
    - 14.1.6 MCP：上下文工程的标准化
    - 14.1.7 上下文工程的关键技术
- 上下文卸载示例：将工具输出写入文件
- 紧凑化示例
  - 之前的工作摘要
    - 14.1.8 实践指南：设计上下文工程系统
    - 14.1.9 上下文工程的未来方向
    - 14.1.10 设计哲学：避免过度工程化
    - 思考

## 14_future/14.2_multi_agent.md
  - 14.2 多 Agent 协作与编排
    - 14.2.1 为什么需要多 Agent
    - 14.2.2 多 Agent 架构模式
    - 14.2.3 主流多 Agent 框架
- 定义状态
- 构建图
- 添加节点
- 定义边（流转逻辑）
- 编译运行
- 定义 Agent
- 定义任务
- 组建团队执行
- 创建 Agent
- 发起群聊
    - 14.2.4 Agent 间通信设计
    - 14.2.5 实战协作模式
- 定义输出 Schema
- 子 Agent 必须按此格式提交结果
    - 14.2.6 多 Agent 提示词设计原则
  - 任务完成报告
    - 延伸思考

## 14_future/14.3_career.md
  - 14.3 提示词工程的职业发展
    - 14.3.1 新兴职业角色
    - 14.3.2 核心技能体系
    - 14.3.3 职业发展路径
    - 14.3.4 学习资源与路径
    - 14.3.5 行业薪资参考（2025-2026）
    - 14.3.6 保持竞争力的建议
    - 想一想

## 14_future/14.4_industry_cases.md
  - 14.4 行业应用案例与最佳实践
    - 14.4.1 客户服务行业
    - 14.4.2 内容创作行业
    - 14.4.3 软件开发行业
    - 14.4.4 数据分析行业
    - 14.4.5 教育培训行业
    - 14.4.6 医疗健康行业
    - 14.4.7 跨行业通用最佳实践
    - 实践建议

## 14_future/summary.md
- 第十四章：未来趋势与展望
  - 本章小结
    - 核心趋势
    - 关键洞察
    - 延伸阅读
    - 结语

## appendix/a_templates.md
- 附录A：常用提示词模板库
  - A.1 文本分析类
    - A.1.1 情感分析
    - A.1.2 主题提取
    - A.1.3 实体识别
  - A.2 内容生成类
    - A.2.1 营销文案
    - A.2.2 文章大纲
    - A.2.3 社交媒体帖子
  - A.3 数据处理类
    - A.3.1 信息提取
    - A.3.2 表格数据分析
  - A.4 代码相关
    - A.4.1 代码解释
    - A.4.2 代码生成
    - A.4.3 Bug诊断
  - A.5 教育学习类
    - A.5.1 概念解释
    - A.5.2 学习计划
  - A.6 客户服务类
    - A.6.1 FAQ回答
    - A.6.2 投诉处理
  - A.7 翻译类
    - A.7.1 专业翻译
    - A.7.2 本地化
  - A.8 研究分析类
    - A.8.1 文献综述
    - A.8.2 竞品分析
  - 使用说明

## appendix/b_glossary.md
- 附录B：术语表
  - A
  - B
  - C
  - D
  - E
  - F
  - G
  - H
  - I
  - J
  - L
  - M
  - O
  - P
  - R
  - S
  - T
  - V
  - Z
  - 新增术语（2025年更新）

## appendix/c_resources.md
- 附录C：资源、工具与参考文献
  - C.1 官方指南与文档 (Official Guidelines)
    - C.1.1 OpenAI
    - C.1.2 Anthropic
    - C.1.3 Google
  - C.2 核心参考文献与研究论文 (Foundational Papers & Research)
    - C.2.1 基础与综述类
    - C.2.2 推理与思维链 (Reasoning & CoT)
    - C.2.3 工具调用与 Agent (ReAct & Agents)
    - C.2.4 自动化与评测 (Automated PE)
    - C.2.5 检索增强生成 (RAG)
  - C.3 开源框架与开发工具 (Frameworks & Tools)
    - C.3.1 开发框架
    - C.3.2 测试与评测工具
    - C.3.3 向量数据库
    - C.3.4 其他项目
  - C.4 实用平台与测试工具 (Practical Toolings)
    - C.4.1 提示词测试
    - C.4.2 Token计算
    - C.4.3 提示词优化
  - C.5 扩展学习资源 (Extended Learning)
    - C.5.1 在线课程
    - C.5.2 博客与社区
    - C.5.3 数据集与Benchmark
    - C.5.4 持续学习
  - 使用建议

## appendix/d_taxonomy_index.md
- 附录D：提示词技术分类索引
  - D.1 为什么需要分类体系
  - D.2 提示词技术分类图谱
  - D.3 核心类别详解
    - D.3.1 基础交互范式
    - D.3.2 推理增强策略
    - D.3.3 外部能力增强
    - D.3.4 可靠性集成策略
  - D.4 技术选型决策流程
  - D.5 本书结构与分类体系的对应
    - 讨论

## appendix/e_anti_patterns.md
- 附录 E：提示词常见反模式与排错指南
  - E.1 冗余与过度限定 (Over-prompting)
  - E.2 负向指令优先 (Negative-first Instructing)
  - E.3 单次调用的超载 (God Prompt)
  - E.4 强制格式的硬换行与缩进敏感
  - E.5 缺乏退路 (No Escape Hatch)
  - E.6 在 System Prompt 中附带用户请求
  - E.7 盲目依赖 Few-Shot (Blind Few-Shot)
  - E.8 上下文污染与无差别检索 (Context Pollution)
  - 小结
