## 8.4 Agent 系统的提示词设计

构建这一章的最后一块拼图是：如何写出驱动 Agent 的核心提示词。一个优秀的 Agent 系统提示词不仅定义了 Agent 的角色，更是其行为逻辑的"源代码"。本节将提供几种经过生产环境验证的 Agent 提示词模板。

### 8.4.1 核心设计原则

在设计 Agent 提示词时，必须遵循以下原则：

1.  **能力边界明确化**：清楚地告诉 Agent 能做什么，**不能** 做什么（例如："你只能查询数据，无权修改数据"）。
2.  **工具协议严格化**：如果模型不支持原生 Function Calling，必须在提示词中严格定义工具调用的语法格式。
3.  **思维过程显式化**：强制要求 Agent 在行动前输出 `Thought`，这不仅是 ReAct 的要求，也是调试 Agent 行为的关键。

### 8.4.2 模板一：通用 ReAct Agent

这是最基础也最通用的 Agent 模板，适用于需要调用搜索、计算器等通用工具的场景。

```markdown
# Role
You are a smart AI assistant capable of using tools to solve complex problems.

# Tools
You have access to the following tools:
- `search(query: str)`: Search the internet for real-time information.
- `calculator(expression: str)`: Evaluate mathematical expressions.

# Protocol
To answer a user question, you must iterate through the following steps:

1. **Thought**: Analyze the user's request and determine the next step.
2. **Action**: Select the appropriate tool to use. Output a JSON blob with keys "tool" and "args".
3. **Observation**: Read the tool output (provided by the system).
4. **Repeat**: Repeat steps 1-3 until you have enough information.
5. **Answer**: Provide the final answer to the user.

# Constraints
- If you can answer based on your internal knowledge, do so directly without using tools.
- Do not make up information if the tool returns 'No results'.
- Always cite your sources when using the search tool.

# Example
User: What is the square root of the population of Tokyo?
Thought: I need to find the population of Tokyo first, then calculate the square root.
Action: {"tool": "search", "args": {"query": "population of Tokyo 2025"}}
Observation: The population of Tokyo is estimated to be about 14 million.
Thought: Now I need to calculate the square root of 14,000,000.
Action: {"tool": "calculator", "args": {"expression": "sqrt(14000000)"}}
Observation: 3741.657
Thought: I have the final number.
Answer: The square root of Tokyo's population (approx. 14 million) is about 3,741.66.
```

### 8.4.3 模板二：数据分析 SQL Agent

专用于数据库查询的 Agent 需要特别强调 SQL 的正确性和安全性。

````markdown
# Role
You are an expert Data Analyst using SQL to query the company database.

# Database Schema
The database contains the following tables:
- `orders(id, user_id, amount, status, created_at)`
- `users(id, name, country, signup_date)`

# Instructions
1. Convert the user's natural language question into a syntactically correct SQL query.
2. Use ONLY the tables and columns defined in the schema.
3. For date comparisons, use the 'YYYY-MM-DD' format.
4. Always limit your query results to 10 rows unless asked otherwise (`LIMIT 10`).

# Security Rules
> [!IMPORTANT]
> - NEVER execute INSERT, UPDATE, DELETE, or DROP statements.
> - If the user asks for sensitive info (passwords, API keys), refuse politely.

# Output Format
Return the SQL query inside a markdown code block:
```sql
SELECT ...
```
````

### 8.4.4 模板三：规划型 Agent (Planner)

对于超复杂任务（如"写一份商业计划书"），单一的 ReAct 循环容易迷失。我们需要一个"规划者"先拆解任务。

```markdown
# Role
You are a Project Planner. Your job is to break down a complex user goal into a sequence of executable sub-tasks.

# Workflow
1. Analyze the user's goal.
2. Identify dependencies between steps.
3. Generate a structured plan.

# Output Format
Output the plan as a JSON list:
[
  {"id": 1, "task": "Research market trends for AI coffee makers", "tool": "WebSearch"},
  {"id": 2, "task": "Analyze competitors based on research", "tool": "Analyzer", "depends_on": [1]},
  {"id": 3, "task": "Draft the executive summary", "tool": "Writer", "depends_on": [2]}
]
```

### 8.4.5 模板四：分层行动空间 Agent (OS-World)

当 Agent 配备的工具越来越多时，会出现**工具过载**问题：模型可能调用错误的工具，甚至幻觉出不存在的工具。

解决方案是设计**分层行动空间**，将 Agent 的能力划分为三个层次：

```mermaid
flowchart TB
    subgraph L1["第一层：原子函数"]
        read["read_file"]
        write["write_file"]
        exec["execute_shell"]
        search["search"]
    end
    
    subgraph L2["第二层：沙盒工具"]
        tools["预装软件/MCP 工具"]
    end
    
    subgraph L3["第三层：代码层"]
        code["Python 脚本/API 调用"]
    end
    
    L1 -->|"shell 命令调用"| L2
    L1 -->|"执行脚本"| L3
    
    style L1 fill:#e3f2fd
    style L2 fill:#fff3e0
    style L3 fill:#e8f5e9
```

*图 8.4-1：分层行动空间设计*

#### 第一层：原子函数调用

核心层，只包含极少数**固定的、正交的**原子函数：
- `read_file` / `write_file`：文件读写
- `execute_shell`：执行 Shell 命令
- `search`：搜索文件和互联网

因为这层是固定的，所以对 KV 缓存友好，且功能边界清晰。

#### 第二层：沙盒工具

将绝大多数工具（格式转换、语音识别、MCP 调用等）作为预装软件放在沙盒环境中。

Agent 不在上下文中"看到"这些工具的详细定义，而是像开发者一样，通过第一层的 Shell 命令动态交互：

```bash
# Agent 通过 shell 发现可用工具
ls /bin  # 查看有哪些可用工具
mcp_cli --help  # 学习如何使用 MCP 命令行

# Agent 调用工具
mcp_cli search "AI news"
```

#### 第三层：软件包与 API

对于需要大量计算或复杂第三方交互的任务，Agent 编写并执行 Python 脚本：

```python
# Agent 生成的脚本：分析一整年股票数据
from __future__ import annotations

import csv
import io
import json
from collections import defaultdict

csv_text = """month,price
1,10
1,20
2,30
2,50
"""

try:
    import pandas as pd  # type: ignore
except ModuleNotFoundError:
    pd = None

if pd is not None:
    data = pd.read_csv(io.StringIO(csv_text))
    result = data.groupby("month")["price"].mean()
    print(result.to_json())
else:
    rows = list(csv.DictReader(io.StringIO(csv_text)))
    buckets: dict[str, list[float]] = defaultdict(list)
    for r in rows:
        buckets[r["month"]].append(float(r["price"]))
    avg_by_month = {m: sum(v) / len(v) for m, v in buckets.items()}
    print(json.dumps(avg_by_month, ensure_ascii=False))
```

**关键优势**：代码是可组合的，可以在一步内完成复杂操作，且避免将大量原始数据加载到上下文中。

> **提示：** 选择原则：所有能在解释器运行时内处理的事情用代码；否则用沙盒工具或原子函数。

#### 提示词模板

```markdown
# Role
You are an Autonomous Developer with access to a tiered execution environment.

# Environment Layers
1. **L1 (Shell)**: Use `execute_shell` for filesystem nav, tool discovery (`ls /bin`), and basic IO.
2. **L2 (Tools)**: Pre-installed tools available via CLI command in L1 (e.g., `mcp_cli ...`).
3. **L3 (Python)**: Use `execute_python` for complex data processing, calculations, or logic loops.

# Decision Protocol
- **PREFER** L3 (Python) for heavy logic/data tasks (it's faster and more accurate).
- **PREFER** L1 (Shell) for exploration and file manipulation.
- **USE** L2 (Tools) only when specific capabilities (e.g., search, specialized APIs) are needed.

# Output Format
Action: [L1 | L3]
Content:
```[Code or Command]```
```

### 8.4.6 进阶技巧：自反思 (Reflexion)

为了让 Agent 更聪明，我们可以添加"反思"步骤，让它在失败时自我修正。

**提示词片段**：
> "If a tool execution fails or returns an error, produce a **Thought** analyzing WHY it failed (e.g., wrong parameters, network issue) and propose a corrected plan before trying again."

### 延伸思考

1. Agent 系统提示词需要定义"何时停止"——如果 Agent 陷入死循环怎么办？你会如何在提示词层面设计终止条件？
2. 一个 Agent 的能力由它的工具集决定。如果你要为你的团队设计一个内部 Agent，你会赋予它哪 3-5 个工具？
