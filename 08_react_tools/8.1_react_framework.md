## 8.1 ReAct 框架：推理与行动的结合

在提示词工程的发展历程中，**ReAct (Reasoning and Acting)** 框架的提出是一个重要的里程碑。它由 [Yao et al. (2022)](https://arxiv.org/abs/2210.03629) 首次提出，核心思想是将大语言模型的 **推理能力**（Reasoning）与 **行动能力**（Acting）有机结合，使模型能够像人类一样，在解决问题时交替进行思考和行动，从而解决需要实时信息或多步骤交互的复杂任务。

### 8.1.1 核心原理：超越思维链

在 ReAct 出现之前，主流的提示技术主要分为两类：
1.  **推理型（如 CoT）**：让模型生成推理步骤，但不与外部世界交互。这限制了模型获取新知识的能力，容易产生幻觉。
2.  **行动型（如 WebGPT）**：让模型生成指令调用工具，但缺乏对行动策略的显式推理。

ReAct 巧妙地融合了这两者，形成了一个**"思考-行动-观察"（Thought-Action-Observation）** 的闭环。

#### ReAct 的工作流程

ReAct 的决策过程可以形象地描述为以下循环：

```mermaid
flowchart TB
    Start(["开始任务"]) --> Thought["Thought: 思考当前状态"]
    Thought --> Action["Action: 选择下一步行动"]
    Action --> Execute[["执行工具调用"]]
    Execute --> Observation["Observation: 观察执行结果"]
    Observation --> Check{"是否完成?"}
    Check -->|"否"| Thought
    Check -->|"是"| Answer["Answer: 生成最终答案"]
    Answer --> Stop(["结束"])

    style Thought fill:#e3f2fd,stroke:#1565c0
    style Action fill:#fff3e0,stroke:#e65100
    style Observation fill:#e8f5e9,stroke:#2e7d32
    style Answer fill:#f3e5f5,stroke:#7b1fa2
```

*图 8.1-1：ReAct 的标准决策循环*

在这个循环中：
-   **Thought（思考）**：模型分析当前的任务状态、已有的信息，规划下一步应该做什么。这一步利用了 LLM 的逻辑推理能力。
-   **Action（行动）**：模型决定调用哪个外部工具（如搜索引擎、计算器、API），并生成具体的调用参数。
-   **Observation（观察）**：工具执行后返回的结果（如搜索结果片段、计算数值、API 响应）。这部分信息被回填到模型的上下文中。

通过这种方式，ReAct 实际上是在**利用外部工具来扩展模型的上下文窗口和知识边界**。

### 8.1.2 实战示例：ReAct 解决复杂问题

让我们通过一个具体案例，对比标准提示与 ReAct 的差异。

**任务**：*"除了 Apple，哪家公司发布的消费级 AR 眼镜在 2025 年销量最高？它的主要卖点是什么？"*

#### ❌ 标准提示（容易失败）

> **用户**：除了 Apple，哪家公司发布的消费级 AR 眼镜在 2025 年销量最高？它的主要卖点是什么？
>
> **模型**：2025 年销量最高的消费级 AR 眼镜可能是 Xreal 的 Air 3 系列。它的主要卖点包括轻便的机身设计、高清的 Micro-OLED 显示屏以及相对亲民的价格。
>
> **分析**：这个回答可能是基于模型训练数据的"幻觉"或过时信息，缺乏实时数验证。

#### ✅ ReAct 提示（准确可靠）

> **系统提示词**：
> 你是一个智能助手。在回答问题前，请遵循 ReAct 格式：先思考，再行动，观察结果，最后回答。
> 可用工具：
> - `search(query)`: 搜索引擎
> - `browser(url)`: 浏览网页内容
>
> **模型执行过程**：
>
> **Thought 1**: 用户询问 2025 年销量最高的非 Apple AR 眼镜。我需要先查找 2025 年 AR 眼镜市场的销量统计数据或报告。
> **Action 1**: `search("best selling consumer AR glasses 2025 market share excluding Apple")`
> **Observation 1**: [搜索结果]根据 IDC 和 Counterpoint 的 2025 年度报告，Ray-Ban Meta 2 代销量持续领跑。Xreal Air 3 Ultra 在纯显示类 AR 中位居第一。Rokid Station 2 也有不错表现...
>
> **Thought 2**: 搜索结果提到了 Ray-Ban Meta 2 和 Xreal。Ray-Ban Meta 本质上是智能音频眼镜，但也常被归类在广义 AR/智能眼镜中。Xreal 是纯 AR 眼镜。我需要确认"消费级 AR 眼镜"的具体定义下谁的销量最高，并查找其卖点。
> **Action 2**: `search("Ray-Ban Meta 2 vs Xreal Air 3 sales 2025")`
> **Observation 2**: [搜索结果] Ray-Ban Meta 2 在 2025 年出货量突破 300 万台，远超其他竞品。虽主要是音频+拍摄+HUD提示，但被广泛视为最成功的智能眼镜产品。Xreal Air 3 系列销量在 80 万量级。
>
> **Thought 3**: 既然 Ray-Ban Meta 2 销量断层领先，且符合"消费级"定义，我应该重点介绍它。接下来查找它的主要卖点。
> **Action 3**: `browser("https://www.meta.com/smart-glasses/")`
> **Observation 3**: [网页内容] 卖点：1. 全新的 HUD 抬头显示；2. 2400MP 超广角相机；3. 实时多语种翻译；4. 手势控制；5. 仅重 48g。
>
> **Thought 4**: 我已经有了足够的信息：销量最高的是 Ray-Ban Meta 2，卖点也已明确。
> **Answer**: 除去 Apple Vision Pro，2025 年销量最高的消费级智能/AR 眼镜是 **Ray-Ban Meta 2**。
>
> 它的主要卖点包括：
> 1.  **HUD 抬头显示**：在保持普通外观的同时集成了微型投影，可显示导航和通知。
> 2.  **轻量化设计**：仅重 48g，解决了长期佩戴的痛点。
> 3.  **多模态 AI**：支持实时物体识别和翻译，不仅是拍摄工具，更是生活助手。
> 4.  **手势交互**：无需触碰眼镜，通过微手势即可控制。

### 8.1.3 ReAct 的代码实现逻辑

在实际开发中，ReAct 并不神秘，其实质是一个 `While` 循环。以下是一个简化的 Python 实现伪代码：

```python
def react_loop(query, tools, max_steps=10):
    messages = [
        {"role": "system", "content": SYSTEM_PROMPT},
        {"role": "user", "content": query}
    ]
    
    step_count = 0
    while step_count < max_steps:
        # 1. 调用 LLM 生成 Thought 和 Action
        response = llm.generate(messages)
        message = response.choices[0].message
        messages.append(message)
        
        # 2. 检查是否决定结束（生成 Answer）
        if "Answer:" in message.content:
            return extract_answer(message.content)
            
        # 3. 解析 Action
        tool_name, tool_args = parse_action(message.content)
        
        # 4. 执行 Action (Execute)
        if tool_name in tools:
            observation = tools[tool_name](tool_args)
            
            # 5. 将 Observation 回填给 LLM
            messages.append({
                "role": "tool",
                "content": f"Observation: {observation}"
            })
        else:
            messages.append({
                "role": "system", 
                "content": "Error: Tool not found."
            })
            
        step_count += 1
        
    return "Task timed out."
```

### 8.1.4 ReAct 的优势与局限

#### 核心优势
1.  **可解释性强**：不仅知道结果，还能通过 Thought 看到模型的决策路径。
2.  **实时性与准确性**：通过工具获取最新信息（如天气、股价），解决了 LLM 知识截止的问题。
3.  **鲁棒性**：面对工具调用失败或信息不全，模型可以通过 Thought 自我纠正。

#### 潜在局限
1.  **延迟较高**：每一轮"思考-行动"都需要一次 LLM 调用和一次工具调用，多轮交互会导致显着的延迟。
2.  **上下文消耗**：Thought、Action 和 Observation 的历史记录会迅速占用上下文窗口，可能导致"遗忘"最初的指令。
3.  **循环陷阱**：模型有时会陷入死循环（如反复搜索同一个无效关键词），需要设置最大步数限制和检测机制。

### 想一想

1. ReAct 让模型在"推理"和"行动"之间交替——这和人类解决问题的方式有什么相似之处？有什么关键差异？
2. 如果 ReAct 循环中某一步工具调用失败了，你会如何设计 fallback 策略？
